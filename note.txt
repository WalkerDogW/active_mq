Queue - Point-to-Point (点对点)：
当一个消息生产者产生一个消息时，会把消息放入一个队列(Queue)中，然后消息消费者从Queue中读取消息，如果同时有多个消费者读取消息，ActiveMq保证消息只会被一个消费者读取到，消费者读取到消息之后需要向ActiveMq发送一条确认信息，确认消息已经被接收，此时，队列(Queue)中的消息出队，没被消费的消息会一直存在MQ队列中直到MQ被关闭。

Topic - Publisher/Subscriber Model (发布/订阅者)
消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。 当生产者发布消息，不管是否有消费者。都不会保存消息，所以一定要先有消息的消费者，后有消息的生产者。否则消息产生后会别立刻丢弃。启动项目的时候，先起消费者，再起生产者。



重试
当消费者接收到消息后，如果抛出异常，activemq会自动重试。
如果不需要自动重试，可以把接收消息的代码try起来，在catch里面做处理，比如记录日志或保存数据库，方便后面的补偿。补偿机制可以采用定时任务，定时检查异常日志或数据库记录，进行特定处理，或者人工进行补偿。

保持幂等性
如果进行重试，会导致消息被重复消费，应该要采取措施保持消息幂等性。
通常使用消息的唯一ID（ActiveMq自动生成的，message.getJMSMessageID()）或者使用业务唯一ID进行比对。
比如：在第一次消息被接收时，把消息唯一ID存放在缓存里面。当异常重试的时候，比对到缓存里面是否存在相同的ID，如果存在就进行签收，避免第三次重试。



一个队列如果有多个消费者，默认轮询分配


事务偏生产，签收偏消费